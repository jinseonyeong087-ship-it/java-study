# 혼공자 9~14

## [용어정리 3](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC3.md)  

## 09-01-01
- 중첩 멤버 클래스란?
  - 클래스의 멤버(필드, 메서드)처럼 선언된 클래스
    바깥 클래스의 인스턴스에 종속되는 인스턴스 멤버 클래스를 말함
    즉, 클래스 안에 클래스를 두는데, static이 붙지 않은 경우

- 특징
  - 바깥 클래스의 필드, 메서드에 자유롭게 접근 가능
  - 특히 private 멤버도 접근 가능  

![alt text](img/image-75.png)  
![alt text](img/image-76.png)  
![alt text](img/image-77.png)   
![alt text](img/image-78.png)  

## 09-01-02
- 로컬 클래스란?
  - 메서드 내부에 선언된 클래스  
    즉, 클래스가 메서드 안에서만 쓰이고, 해당 메서드 실행 중에만 유효한 클래스

- 특징
```
-스코프가 메서드 내부로 제한

로컬 클래스는 선언된 메서드 안에서만 보이고, 밖에서는 사용할 수 없음

- 바깥 클래스 멤버 접근 가능

바깥 클래스의 필드, 메서드에 자유롭게 접근 가능
메서드의 final 또는 effectively final 지역 변수에도 접근 가능
```
![alt text](img/image-79.png)  

- 주의할 점
  - 로컬 클래스는 메서드가 호출될 때만 메모리에 로드됨
  - 메서드가 끝나면 로컬 클래스 객체도 사라짐
  - 지역 변수에 접근할 때는 반드시 수정되지 않는 값이어야 함 (effectively final)

## 09-01-03
- Car.java  
![alt text](img/image-93.png)
- NestedClassExample  
![alt text](img/image-94.png)


## 09-01-04
- [컴파일오류](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src/java/example/Chatting.java)  
![alt text](img/image-80.png)  

- 기존 코드 컴파일 오류 원인
```
String nickName = null; → 1차 대입,
nickName = chatId; → 2차 대입.
두 번 대입이라 effectively final이 아님 → 로컬 클래스에서 참조 불가.
```

- effectively final이란?  
final을 안 붙여도 값을 한 번만 대입해서 이후 변경이 없으면 컴파일러가 final처럼 취급

## 09-01-05
- CheckBox class  
![alt text](img/image-81.png)  

- BackgroundChangeListener class  
![alt text](img/image-82.png)  

- CheckBoxExample class    
![alt text](img/image-83.png)


## 09-02-01
- 인터페이스 [Worker.java](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src2/java/exam01/Worker.java)  
![alt text](img/image-84.png)  

- 익명 구현 클래스와 객체 생성 [Anonymous.java](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src2/java/exam01/Anonymous.java)  
![alt text](img/image-85.png)  

- 익명 구현 클래스와 객체 생성 [AnonymousExample.java](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src2/java/exam01/AnonymousExample.java)   
![alt text](img/image-86.png)  

**빌드 & 런(build & run)**
```
javac -encoding UTF-8 -d bin src2\java\exam01\*.java   
java -cp bin src2.java.exam01.AnonymousExample
```

## 09-02-02
- 인터페이스 [Vehicle.java](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src2/java/exam02/Vehicle.java)  
![alt text](img/image-87.png)  

- 익명 구현 클래스와 객체 생성 [Anonymous.java](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src2/java/exam02/Anonymous.java)  
![alt text](img/image-88.png)  

- 익명 구현 클래스와 객체 생성 [AnonymousExample.java](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src2/java/exam02/AnonymousExample.java)  
![alt text](img/image-89.png)  

**빌드 & 런(build & run)**
```
javac -encoding UTF-8 -d bin src2\java\exam02\*.java   
java -cp bin src2.java.exam02.AnonymousExample
```

## 09-02-03
- 인터페이스 [CheckBox.java]()  
![alt text](img/image-90.png)  

- 익명 구현 클래스와 객채 생성 []()  
![alt text](img/image-91.png)  

**빌드 & 런(build & run)**
```
javac -encoding UTF-8 -d bin src2\java\exam03\*.java   
java -cp bin src2.java.exam03.CheckBoxExample
```

## 10-01-01
- 예외(Exception)
```
프로그램 실행 중 정상적이지 않은 상황(오류)이 발생했을 때 알리는 객체 

RuntimeException의 하위 클래스는 컴파일러가 예외 처리 코드를 체크하지 않는다.

예외는 클래스로 관리 

예외가 발생하면 JVM은 해당 메서드 실행을 중단하고, 예외 처리 코드(try-catch-finally)나 호출자에게 예외를 던집니다.  
즉, 예외는 실행 도중에 생기는 “비정상 사건”을 나타내는 객체
```

- 오류(Error)와 예외(Exception)의 차이
![alt text](img/image-92.png)

## 10-02-01
**try-catch-finally 블록**
- 예외(에러)가 발생했을 때 프로그램이 중단되지 않고 안전하게 처리할 수 있도록 해주는 구문  
  Java, C#, Python(try-except-finally) 등 대부분의 언어에서 지원  
```
1. try 블록
- 예외가 발생할 가능성이 있는 코드를 넣는 부분
- 예외가 발생하면 즉시 catch로 이동하고, 남은 try 코드는 실행되지 않습니다.

2. catch 블록
- try에서 발생한 예외를 잡아 처리하는 부분입니다.
- 여러 개의 catch를 작성할 수 있으며, 예외 타입별로 다른 처리 가능.
- Exception을 마지막에 두어 예상하지 못한 모든 예외를 처리하는 것이 일반적입니다.

3. finally 블록
- 무조건 실행됩니다. (예외가 발생해도, return으로 메서드를 빠져나가도 실행)
- 주로 리소스 해제(파일 닫기, DB 연결 해제 등)에 사용
```
- 실행 순서
```
1. try 블록 실행 → 예외 발생 시점에서 중단

2.발생한 예외와 일치하는 catch 블록 실행

3. 마지막에 finally 블록 실행

4. 예외가 없으면 catch는 건너뛰고 finally만 실행
```
**finally에서 자원 해제 코드를 작성하면 예외 발생 여부와 관계없이 안전하게 정리 가능**

## 10-02-02
**throws**
- try-catch-finally와는 달리 "예외를 직접 처리하지 않고 호출한 쪽으로 넘기는 역할"
- 생성자나 메소드의 선언 끝 부분에 사용되어 내부에서 발생된 예외를 떠넘긴다.
- throws 뒤에는 떠넘겨야 할 예외를 쉼표(,)로 구분해서 기술
- 모든 예외를 떠넘기기 위해 간단하게 throws Exception으로 작성할 수 있다.

## 10-02-03
**예외처리**
```
public void method1() throws NumberFormatException, ClassNotFoundException {...}
```
①
catch(Exception e)

Exception은 ClassNotFoundException도 포함.

NumberFormatException은 RuntimeException이라 안 잡아도 되고, 잡으면 문제 없음.
✅ 올바른 예외 처리.
```
try {
    method1();
} catch (Exception e) {
}
```
## 11-01-01
```
모든 자바 클래스의 최상위 부모 클래스이다.
Object 의 equals() 메소드는 == 연산자와 동일하게 번지를 비교한다.
동등 비교를 위해 equals()와 hashCode() 메소드를 재정의하는 것이 좋다.
```
- Object 클래스
  - 자바에서 모든 클래스는 java.lang.Object를 상속
  - 명시적으로 extends를 안 써도 자동으로 상속
  - 모든 클래스는 Object의 메소드를 사용할 수 있음
  
  ![alt text](img/image-62.png)
  ![alt text](img/image-63.png)

## 11-01-02
- Object의 equals()와 hashCode() 메소드를 재정의 했을 때 메소드 호출 순서
![alt text](img/image-64.png)

## 11-01-03
안풀림