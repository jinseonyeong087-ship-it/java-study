# 용어정리 2

## 힙(Heap)
- JVM(Java Virtual Machine) 메모리에서 객체(Instance)가 저장되는 영역  
- new 키워드로 생성한 모든 객체와 배열이 여기 저장
- 모든 스레드(Thread)가 공유하는 메모리 영역  
- 동적 메모리 할당(Dynamic Allocation) : 프로그램 실행 중에 객체가 필요할 때마다 new 로 만들고 힙에 저장.

## 인덱스(index)
- 배열, 문자열, 리스트 등에서 데이터의 "위치"를 나타내는 번호 (0부터 시작 → 첫 번째 요소는 인덱스 0, 두 번째는 인덱스 1, 마지막 인덱스 = length - 1)

## Integer.parseInt
- 자바에서 문자열을 정수(int) 로 변환할 때 사용하는 정적 메서드

## Integer.MIN_VALUE
- 최댓값 구하기에 활용 (Integer.MAX_VALUE는 최솟값 구하기)
- 자바에서 int 타입이 가질 수 있는 가장 작은 값을 의미하는 상수
- 왜 MIN_VALUE로 초기화하나?  
→ 어떤 값이 들어와도 첫 번째 비교에서 무조건 갱신되도록 하기 위해
(만약 0으로 시작하면, 모든 값이 0보다 작을 때 max가 잘못 남을 수 있음)

## 생성자 
- 생성자(Constructor)는 클래스의 객체(인스턴스)가 생성될 때 자동으로 호출되는 특수한 메서드
- 특징 :
  - 클래스 이름과 동일한 이름을 가져야 한다.  
  - 리턴 타입이 없다 (void도 쓰지 않음).  
  - 객체를 만들 때 new 키워드와 함께 호출  
  - 여러 개를 만들면 생성자 오버로딩(overloading)이 가능

## void
- 메서드의 반환(return) 타입을 나타낼 때 쓰는 키워드
  ```
  class Printer {
    // 반환값 없음 → 그냥 출력만 하는 메서드
    void printHello() {
        System.out.println("안녕하세요!");
    }

    // 반환값 있는 메서드 (참고)
    String getHello() {
        return "안녕하세요!";
    }
  }

## this()
- this(...)는 같은 클래스 안의 다른 생성자를 호출할 때 사용
- 반드시 생성자의 첫 줄에 있어야 합니다. (안 지키면 컴파일 에러)

## 인스턴스 필드 (instance field)
- 클래스 안에 선언된 변수. 각 객체(인스턴스)마다 독립적으로 존재하는 변수
- 객체가 생성될 때(new로 만들 때) 힙(heap) 메모리에 따로 저장
- 서로 다른 객체는 서로 다른 값을 가진다.

## 정적 필드 (static field)
- 클래스 변수(Class Variable) 라고도 부름.
- static 키워드를 붙여 선언한 필드.
- 클래스 로드 시점에 단 한 번 생성. 모든 인스턴스(객체)가 값을 공유
- 객체를 만들지 않아도 클래스명.필드명 으로 접근 가능.

## 인스턴스 필드와 정적 필드의 차이  
![alt text](img/image-32.png)

## 오버로딩(Overloading)
- 같은 이름의 메서드(또는 생성자)를 매개변수의 타입·개수·순서로 구분해서 여러 개 정의하는 것.
- 메서드뿐 아니라 생성자도 오버로딩 가능  
![alt text](img/image-49.png)

## 오버라이딩(Overriding)
- 상속 관계에서 부모 클래스에 정의된 메소드를 자식 클래스에서 같은 이름·같은 매개변수로 다시 정의 (부모의 메소드를 덮어쓰기(재정의))  
![alt text](img/image-53.png)  
![alt text](img/image-54.png)

## 매개변수(Parameter)
- 메소드를 호출할 때 외부에서 전달받은 값을 저장하기 위한 변수 (메소드 선언부(괄호 안) 에 적는 변수)

## 싱글톤(Singleton)
- 프로그램 전체에서 단 하나의 객체만 존재하도록 보장
- 장점
  - 메모리 절약 (여러 개 만들 필요 없음)
  - 전역에서 같은 객체 사용 → 데이터 일관성 유지
- 단점
  - 너무 많이 쓰면 전역 변수 남용처럼 되어 설계가 복잡해질 수 있음
  - 멀티스레드 환경에서 안전하게 만들려면 조금 더 신경 써야 함
```
┌──────────────┐
│  Singleton   │  <─ 클래스 로딩 시 메모리에 올라감
├──────────────┤
│ instance (*) │─┐   (static 필드, 1개만 존재)
└──────────────┘ │
                 │
     ┌───────────▼───────────┐
     │  Heap Memory          │
     │  new Singleton()  (*) │  ← 최초 1번만 생성
     └───────────────────────┘
```

## 패키지 (package)
- 클래스들을 묶어서 관리하는 폴더(디렉터리) 개념  
- 클래스 파일들을 정리하는 폴더이자 이름공간(namespace) → 이름 충돌 방지 + 코드 관리 + 접근제어 용이

## 접근 제한자 (Access Modifier)
- 자바 접근 제한자 종류  
![alt text](img/image-33.png)

## 접근자(accessor)
- 클래스의 필드(멤버 변수)에 안전하게 접근하기 위한 메서드  
- Getter(읽기용 - 필드 값을 외부에서 읽어올 때 사용.)와 Setter(쓰기용 - 필드 값을 외부에서 변경할 때 사용.)로 나뉘며, 이 둘을 묶어 프로퍼티 접근 메서드

## import문
- 다른 패키지에 있는 클래스나 인터페이스를 현재 소스에서 쉽게 쓰기 위해 불러오는 선언문  
없으면 → 패키지 이름까지 전부 써야 함  
있으면 → 클래스 이름만 바로 사용 가능

- import * (와일드카드) : 패키지 안의 모든 클래스를 불러올 때 사용  

- import static (정적 import) : 클래스의 static 필드나 메소드를 패키지명·클래스명 없이 직접 사용 가능하게 한다.

## super()
- 상속에서 부모 클래스 생성자를 호출하는 키워드

## instanceof 연산자
- 객체가 특정 클래스(또는 그 하위 클래스)의 인스턴스인지 검사하는 연산자

## @Override
- 의미 : 이 메서드는 부모 클래스(또는 인터페이스)의 메서드를 재정의(Override)한 것
- 역할 : 파일러에게 "이건 오버라이딩이야, 확인해 줘!"라고 알려줌 → 잘못 재정의하면 컴파일 에러 발생시켜줌.

## 컴파일
- 소스 코드(.java) → 바이트코드(.class) 로 변환하는 과정
  이 변환을 해주는 프로그램이 바로 자바 컴파일러(javac)
```
[내 코드: HttpServletExample.java]
      │
      ▼ (javac)
[바이트코드: HttpServletExample.class]
      │
      ▼ (java)
[JVM이 실행 → 콘솔 출력]
```
![alt text](img/image-70.png)