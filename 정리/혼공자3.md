# 혼공자 9~14

## [용어정리 3](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/%EC%A0%95%EB%A6%AC/%EC%9A%A9%EC%96%B4/%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC3.md)  

## 09-01-01
- 중첩 멤버 클래스란?
  - 클래스의 멤버(필드, 메소드)처럼 선언된 클래스
    바깥 클래스의 인스턴스에 종속되는 인스턴스 멤버 클래스를 말함
    즉, 클래스 안에 클래스를 두는데, static이 붙지 않은 경우

- 특징
  - 바깥 클래스의 필드, 메소드에 자유롭게 접근 가능
  - 특히 private 멤버도 접근 가능  

![alt text](/img/image-75.png)  
![alt text](/img/image-76.png)  
![alt text](/img/image-77.png)   
![alt text](/img/image-78.png)  

## 09-01-02
- 로컬 클래스란?
  - 메소드 내부에 선언된 클래스  
    즉, 클래스가 메소드 안에서만 쓰이고, 해당 메소드 실행 중에만 유효한 클래스

- 특징
```
-스코프가 메소드 내부로 제한

로컬 클래스는 선언된 메소드 안에서만 보이고, 밖에서는 사용할 수 없음

- 바깥 클래스 멤버 접근 가능

바깥 클래스의 필드, 메소드에 자유롭게 접근 가능
메소드의 final 또는 effectively final 지역 변수에도 접근 가능
```
![alt text](/img/image-79.png)  

- 주의할 점
  - 로컬 클래스는 메소드가 호출될 때만 메모리에 로드됨
  - 메소드가 끝나면 로컬 클래스 객체도 사라짐
  - 지역 변수에 접근할 때는 반드시 수정되지 않는 값이어야 함 (effectively final)

## 09-01-03
- Car.java  
![alt text](/img/image-93.png)
- NestedClassExample  
![alt text](/img/image-94.png)


## 09-01-04
- [컴파일오류](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src/java/example/Chatting.java)  
![alt text](/img/image-80.png)  

- 기존 코드 컴파일 오류 원인
```
String nickName = null; → 1차 대입,
nickName = chatId; → 2차 대입.
두 번 대입이라 effectively final이 아님 → 로컬 클래스에서 참조 불가.
```

- effectively final이란?  
final을 안 붙여도 값을 한 번만 대입해서 이후 변경이 없으면 컴파일러가 final처럼 취급

## 09-01-05
- CheckBox class  
![alt text](/img/image-81.png)  

- BackgroundChangeListener class  
![alt text](/img/image-82.png)  

- CheckBoxExample class    
![alt text](/img/image-83.png)


## 09-02-01
- 인터페이스 [Worker.java](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src2/java/exam01/Worker.java)  
![alt text](/img/image-84.png)  

- 익명 구현 클래스와 객체 생성 [Anonymous.java](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src2/java/exam01/Anonymous.java)  
![alt text](/img/image-85.png)  

- 익명 구현 클래스와 객체 생성 [AnonymousExample.java](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src2/java/exam01/AnonymousExample.java)   
![alt text](/img/image-86.png)  

**빌드 & 런(build & run)**
```
javac -encoding UTF-8 -d bin src2\java\exam01\*.java   
java -cp bin src2.java.exam01.AnonymousExample
```

## 09-02-02
- 인터페이스 [Vehicle.java](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src2/java/exam02/Vehicle.java)  
![alt text](/img/image-87.png)  

- 익명 구현 클래스와 객체 생성 [Anonymous.java](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src2/java/exam02/Anonymous.java)  
![alt text](/img/image-88.png)  

- 익명 구현 클래스와 객체 생성 [AnonymousExample.java](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src2/java/exam02/AnonymousExample.java)  
![alt text](/img/image-89.png)  

**빌드 & 런(build & run)**
```
javac -encoding UTF-8 -d bin src2\java\exam02\*.java   
java -cp bin src2.java.exam02.AnonymousExample
```

## 09-02-03
- 인터페이스 [CheckBox.java]()  
![alt text](/img/image-90.png)  

- 익명 구현 클래스와 객채 생성 []()  
![alt text](/img/image-91.png)  

**빌드 & 런(build & run)**
```
javac -encoding UTF-8 -d bin src2\java\exam03\*.java   
java -cp bin src2.java.exam03.CheckBoxExample
```

## 10-01-01
- 예외(Exception)
```
프로그램 실행 중 정상적이지 않은 상황(오류)이 발생했을 때 알리는 객체 

RuntimeException의 하위 클래스는 컴파일러가 예외 처리 코드를 체크하지 않는다.

예외는 클래스로 관리 

예외가 발생하면 JVM은 해당 메소드 실행을 중단하고, 예외 처리 코드(try-catch-finally)나 호출자에게 예외를 던집니다.  
즉, 예외는 실행 도중에 생기는 “비정상 사건”을 나타내는 객체
```

- 오류(Error)와 예외(Exception)의 차이
![alt text](/img/image-92.png)

## 10-02-01
**try-catch-finally 블록**
- 예외(에러)가 발생했을 때 프로그램이 중단되지 않고 안전하게 처리할 수 있도록 해주는 구문  
  Java, C#, Python(try-except-finally) 등 대부분의 언어에서 지원  
```
1. try 블록
- 예외가 발생할 가능성이 있는 코드를 넣는 부분
- 예외가 발생하면 즉시 catch로 이동하고, 남은 try 코드는 실행되지 않습니다.

2. catch 블록
- try에서 발생한 예외를 잡아 처리하는 부분입니다.
- 여러 개의 catch를 작성할 수 있으며, 예외 타입별로 다른 처리 가능.
- Exception을 마지막에 두어 예상하지 못한 모든 예외를 처리하는 것이 일반적입니다.

3. finally 블록
- 무조건 실행됩니다. (예외가 발생해도, return으로 메소드를 빠져나가도 실행)
- 주로 리소스 해제(파일 닫기, DB 연결 해제 등)에 사용
```
- 실행 순서
```
1. try 블록 실행 → 예외 발생 시점에서 중단

2.발생한 예외와 일치하는 catch 블록 실행

3. 마지막에 finally 블록 실행

4. 예외가 없으면 catch는 건너뛰고 finally만 실행
```
**finally에서 자원 해제 코드를 작성하면 예외 발생 여부와 관계없이 안전하게 정리 가능**

## 10-02-02
**throws**
- try-catch-finally와는 달리 "예외를 직접 처리하지 않고 호출한 쪽으로 넘기는 역할"
- 생성자나 메소드의 선언 끝 부분에 사용되어 내부에서 발생된 예외를 떠넘긴다.
- throws 뒤에는 떠넘겨야 할 예외를 쉼표(,)로 구분해서 기술
- 모든 예외를 떠넘기기 위해 간단하게 throws Exception으로 작성할 수 있다.

## 10-02-03
**예외처리**
```
public void method1() throws NumberFormatException, ClassNotFoundException {...}
```
①
```
try {
    method1();
} catch (Exception e) {
}

catch(Exception e)
Exception은 ClassNotFoundException도 포함.
NumberFormatException은 RuntimeException이라 안 잡아도 되고, 잡으면 문제 없음.
✅ 올바른 예외 처리.
```

②
```
void method2() throws Exception {
    method1();
}

hrows Exception
method2()도 throws Exception으로 선언했으니 ClassNotFoundException도 호출자에게 던질 수 있음.
NumberFormatException은 runtime 예외라 throws 안 적어도 됨.
✅ 문법적으로 문제 없음.
```

③
```
try {
    method1();
} catch (ClassNotFoundException e) {
} catch (NumberFormatException e) {
}

개별 catch

ClassNotFoundException 먼저, 그다음 NumberFormatException.

상속 관계 문제 없음. (서로 관련 없는 예외 타입)
✅ 올바른 예외 처리.
```
## 10-02-04
- [TryCatchFinallyExample](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src2/java/TryCatchFinallyExample.java)  

**출력 결과**
```
10
숫자로 변환할 수 없음
10
인덱스를 초과했음
10

*설명
i=0 → "10" → 정상 파싱 → value=10 → finally 출력 → 10

i=1 → "2a" → NumberFormatException 발생 → catch 출력 → 숫자로 변환할 수 없음 → finally 출력 → 10 (value 유지)

i=2 → 배열 범위 초과 → ArrayIndexOutOfBoundsException 발생 → catch 출력 → 인덱스를 초과했음 → finally 출력 → 10
```

## 11-01-01
```
모든 자바 클래스의 최상위 부모 클래스이다.
Object 의 equals() 메소드는 == 연산자와 동일하게 번지를 비교한다.
동등 비교를 위해 equals()와 hashCode() 메소드를 재정의하는 것이 좋다.
```
- Object 클래스
  - 자바에서 모든 클래스는 java.lang.Object를 상속
  - 명시적으로 extends를 안 써도 자동으로 상속
  - 모든 클래스는 Object의 메소드를 사용할 수 있음
  
  ![alt text](/img/image-62.png)
  ![alt text](/img/image-63.png)

## 11-01-02
- Object의 equals()와 hashCode() 메소드를 재정의 했을 때 메소드 호출 순서
![alt text](/img/image-64.png)

## 11-01-03
- [Student.java](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src2/java/Student.java)  
- [StudentExample.java](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src2/java/StudentExample.java)  

**동작 원리**
```
equals()는 두 Student 객체의 studentNum 값이 같으면 true 반환.

hashCode()도 studentNum 기반으로 계산되기 때문에 HashMap, HashSet에서 같은 객체로 취급됨.

따라서 new Student("1")로 put()한 후, new Student("1")로 get()하면 동일 키로 인식해서 "95" 값이 나옴.
```

## 11-01-04
- [Member.java](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src2/java/Member.java)  
- [MemberExample.java](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src2/java/MemberExample.java)  

**동작 원리**
```
System.out.println(member); → 내부적으로 member.toString() 호출

우리가 toString()을 재정의했으므로 "blue: 이파란" 문자열이 출력됨

만약 toString()을 재정의하지 않았다면 Member@6bc7c054 같은 해시코드 문자열이 나왔을 것임
```

## 11-01-05

**클래스(Class)와 객체(Object)의 관계**  
클래스(Class) = 설계도  

객체(Object) = 설계도를 바탕으로 만든 실제 인스턴스  

**클래스 객체(Class Object)**
```
자바에서 클래스도 하나의 객체
즉, 클래스 자체의 정보(이름, 필드, 메소드 등)를 담고 있는 메타데이터 객체가 존재하고, 이걸 Class 타입으로 다룰 수 있다.

Class.forName() 메소드 또는 객체의 getClass() 메소드로 얻을 수 있다.

클래스의 생성자, 필드, 메소드에 대한 정보를 알아낼 수 있다.

클래스 파일을 기준으로 상대 경로의 리소스의 정보를 얻을 수 있다.
```

- 특징  
![alt text](/img/image-95.png)

## 11-01-06
- [BytesToStringExample]()  

**출력 결과**
```
I love you

- 설명
바이트 값 = 문자 코드 값(숫자) 이고
String 생성 시 JVM이 그 숫자들을 문자로 매핑해서 문자열을 만드는 거예요.
```

## 11-01-07
- [FindAndReplaceExample.java](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src2/java/FindAndReplaceExample.java)  

**출력 결과**
```
자바 문자열이 포함되어 있습니다.
-->모든 프로그램은 Java 언어로 개발될 수 있다.


-설명
indexOf("자바") → "자바"가 있는 위치 인덱스 반환 (없으면 -1)

replace("자바", "Java") → 문자열에서 "자바" 부분만 "Java"로 치환

원본 문자열 str을 새 문자열로 덮어쓰고 다시 출력
```

## 11-01-08
- [IntegerCompareExample.java]() 

**출력 결과**
```
true
false
```
**결과 이유**
```
1. Integer 캐싱 (Integer Cache)
Java에서 Integer는 -128 ~ 127 범위의 값을 미리 캐싱해 둡니다.
Integer obj1 = 100; → 오토박싱 시 Integer.valueOf(100) 호출
valueOf()는 -128~127 범위면 같은 객체를 반환 → 동일 참조
따라서 obj1 == obj2 → true

2. 300은 캐싱 범위 밖
Integer obj3 = 300; → Integer.valueOf(300) 호출
300은 캐싱 범위가 아니므로 새로운 객체 생성
obj3와 obj4는 값은 같지만 서로 다른 객체 참조
obj3 == obj4 → false (주소가 다름)
```

**값 자체를 비교하려면 equals() 사용**

## 11-01-09
- [StringConverExample.java](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src2/java/StringConverExample.java)  

**문자열->정수, 정수->문자열**
```
- Integer.parseInt(strData1)

문자열 "200"을 정수 200으로 변환
반환 타입은 int
잘못된 숫자 문자열이면 NumberFormatException 발생

- String.valueOf(intData2)

정수 150을 문자열 "150"으로 변환
오버로딩 메소드라 int, double, boolean 등 어떤 타입이든 문자열로 바꿔줌
```

## 11-02-01
- [TodayDateExample.java](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src2/java/TodayDateExample.java)  


## 11-02-02
- [TodayDateExample2.java](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src2/java/TodayDateExample2.java)   


## 12-01-01

**스레드**
```
프로세스(Process): 실행 중인 프로그램 (메모리, 자원 독립)

스레드(Thread): 프로세스 안에서 실행되는 작업 흐름(실행 단위)

하나의 프로세스는 **최소 1개 스레드(Main Thread)**를 가지고, 여러 스레드를 동시에 실행할 수도 있음 (멀티스레드)

자바 애플리케이션은 메인 스레드가 main() 메소드를 실행한다.

작업 스레드 클레스는 Thread 클래스를 상속해서 만들 수 있다.

Runnable 객체는 스레드가 실행해야 할 코드를 가지고 있는 객체라고 볼 수 있다.
```

- 특징  
![alt text](/img/image-98.png)

## 12-01-02
- [ThreadExample]()
- [MovieThread]()  
- [MusicRunnable]()  

**설명**
```
1. MovieThread → extends Thread(클래스 자체가 쓰레드 역할)
- MovieThread는 독립적인 실행 흐름(쓰레드)을 가져야 하므로 Thread 클래스를 상속받아야 한다.
  이렇게 하면 start() 메소드를 호출했을 때, 내부적으로 새로운 쓰레드가 만들어지고 run() 메소드가 자동으로 실행

2. MusicRunnable → implements Runnable(실행할 코드만 제공, 쓰레드는 외부에서 만들어 줌)
- 두 번째 작업(음악 재생)은 Runnable 인터페이스를 구현한 클래스로 만듦
  Runnable은 run() 메소드만 가진 간단한 인터페이스이고, Thread 객체에 전달해서 실행할 수 있다.
- 장점 : Runnable 방식은 상속을 쓰지 않아도 되기 때문에 다른 클래스를 상속할 수 있고, 코드 재사용성이 좋다.
  (자바는 다중 상속이 안 되기 때문에 extends Thread는 제한적)

3. ThreadExample → new Thread(new MusicRunnable())(실제로 새로운 쓰레드 생성 & 실행)
- MusicRunnable은 Runnable만 구현했기 때문에 start() 메소드가 없다.
  따라서 Thread 객체를 만들고 그 생성자에 new MusicRunnable()을 넣어야 한다.
```

## 12-01-03
**동기화 메소드**
- 동기화 메소드는 여러 개의 쓰레드가 동시에 같은 객체의 메소드를 호출할 때, 한 번에 하나의 쓰레드만 메소드를 실행할 수 있도록 잠금(lock)을 거는 메소드

- 특징
```
1. 객체 단위로 락을 건다
- 인스턴스 메서드에 synchronized → 해당 객체(this)에 대해 락이 걸림
- static synchronized → 클래스 전체에 대해 락이 걸림 (모든 인스턴스가 공유)

2. 성능 고려 필요
-여러 쓰레드가 동시에 실행할 수 없으므로 병렬성이 떨어짐
-꼭 필요한 경우에만 synchronized를 쓰는 게 좋음

3. 대체 방법
- 메서드 전체가 아니라 일부 블록만 동기화 → synchronized (this) { ... }
- 동시성 컬렉션 (ConcurrentHashMap, CopyOnWriteArrayList 등)을 사용해서 락을 직접 관리하지 않음

- 동기화 메소드는 싱글(단일) 스레드 환경에서는 필요 없다.
- 스레드가 동기화 메소드를 실행할 때 다른 스레드는 다른 동기화 메소드를 호출할 수 없다.
- 동기화 메소드 선언부에는 synchronized 키워드가 필요하다.
```
![alt text](/img/image-99.png)

## 12-02-01
![alt text](/img/image-100.png)
![alt text](/img/image-101.png)

## 12-02-02
**interrupt() 메소드**
- interrupt()는 실행 중인 스레드에게 인터럽트 신호를 보내는 메소드
- 스레드를 강제로 종료시키지는 않고, "인터럽트 상태(interrupted 상태)" 로 표시만 해 줍니다.
- 스레드가 sleep(), wait(), join() 같은 차단(blocked) 상태에 있을 때
→ InterruptedException을 발생시켜 깨어나게 함.
- 스레드가 단순히 실행 중이면
→ 단순히 인터럽트 플래그만 세팅. (직접 isInterrupted()로 확인하고 종료 여부 결정해야 함)
- 아직 interruptedException이 발생하지 않았다면 interrupted(), isInterrupted() 메소드는 true를 리턴한다.

## 12-02-03
- [MovieThread.java](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src2/java/exam05/MovieThread.java)  
- [ThreadExample.java](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src2/java/exam05/ThreadExample.java)   
  
  
- 설명
```
1. interrupt() 호출
- thread.interrupt()가 호출되면 해당 쓰레드의 인터럽트 플래그가 true로 설정

2. 안전 종료 구현
- try-catch로 InterruptedException 처리
   → Thread.sleep() 중 인터럽트가 오면 catch 블록에서 break로 루프 탈출
- Thread.interrupted()로 플래그 확인
   → sleep 중이 아니어도 인터럽트 플래그가 true면 직접 종료

3. 실행 흐름
메인 스레드 → MovieThread 실행 (thread.start())

1초 대기 (Thread.sleep(1000))

메인 스레드 → thread.interrupt() 호출

MovieThread에서 InterruptedException 발생 or Thread.interrupted()가 true

반복문 탈출 → 종료 메시지 출력
```

## 12-02-04
- [ThreadExample.java](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src2/java/exam06/ThreadExample.java)  
- [MovieThread.java](https://github.com/jinseonyeong087-ship-it/java-study/blob/main/src2/java/exam06/MovieThread.java)   

**setDaemon(true) 메서드**
- 역할: 해당 스레드를 데몬 스레드(daemon thread) 로 지정
- 메인 스레드(또는 일반 사용자 스레드)가 모두 종료되면 자동으로 종료되는 보조용 스레드
  (GC 쓰레드, 백그라운드 로거 등이 보통 데몬 스레드로 동작)
- 반드시 start() 전에 setDaemon(true) 호출해야 함
  이미 시작한 스레드를 데몬으로 바꾸면 IllegalThreadStateException 발생
- 데몬 스레드는 메인 스레드가 끝나면 강제 종료되므로 데이터를 안전하게 마무리할 필요가 있을 때는 사용하지 않는 것이 좋음  


- 실행 흐름
```
MovieThread를 생성

thread.setDaemon(true) → 무비 스레드를 데몬 스레드로 변경

thread.start() → 동영상 출력 시작

메인 스레드가 3초간 대기 후 종료

메인 스레드 종료 시 → 데몬 스레드도 자동 종료
```

## 12-02-05
**while문으로 반복적인 작업을 하는 스레드를 종료하는 최선의 방법**
- 조건식에 boolean 타입의 stop 플래그를 이용해서 while문을 빠져나가게 한다.
- 스레드가 반복적으로 일시 정지 상태가 되면 InterruptedException을 발생시켜 예외 처리 코드에서 break문으로 while문을 빠져나가게 한다.
- 스레드가 일시 정지 상태로 가지 않는다면 isInterrupted()나 interrupted() 메소드의 리턴값을 조사해서 true일 경우 break문으로 while문을 빠져나가게 한다.

## 13-01-01
**컬렉션 프레임워크**  

- 특징
```
표준화 : List, Set, Map 같은 공통 인터페이스를 제공 → 구현체를 바꿔도 코드 수정이 최소화됨

제네릭(Generic) 지원 : 타입 안전성 보장 → 잘못된 타입 삽입을 컴파일 시점에 방지

다양한 구현체 제공 : 필요에 따라 ArrayList, LinkedList, HashSet, TreeSet, HashMap, TreeMap 등 선택 가능

알고리즘 제공 : Collections 클래스에 정렬, 탐색, 최소·최대값 등 유틸리티 메서드 내장
```
- 주요 인터페이스  
![alt text](/img/image-103.png)  

- 주요 구현제 간 비교
![alt text](/img/image-104.png)

## 13-01-02
**List 컬렉션**
- List는 자바 컬렉션 프레임워크에서 가장 많이 쓰이는 컬렉션 중 하나
- 대표적인 구현 클래스로는 ArrayList, Vector, LinkedList가 있다.
- 중간 위치에 객체를 빈번히 삽입하거나 제거할 경우 LinkedList를 사용하는 것이 좋다.


- List의 개념
```
순서(인덱스)가 있는 컬렉션
→ 배열처럼 0부터 시작하는 인덱스로 요소를 관리

중복 허용
→ 같은 값 여러 개 저장 가능

삽입 순서 유지
→ 먼저 넣은 값이 앞쪽 인덱스에 그대로 저장됨

즉,순서대로 데이터를 저장하고, 필요하면 중복도 허용"하는 자료구조
```

## 13-01-03
**Set 컬렉션**
- Set은 “중복을 허용하지 않는 집합(Collection)
- 대표적인 구현 클래스는 HashSet, LinkedHashSet, TreeSet이 있다.
- Set 컬렉션에서 객체를 하나씩 꺼내오고 싶다면 Iterator를 이용한다.
- HashSet은 hashCode()와 equqls()를 이용해서 중복된 객체를 판별한다.

- Set의 개념
```
순서가 없음
→ 넣은 순서대로 저장되지 않음 (단, 일부 구현체는 유지 가능)

중복 허용 X
→ 같은 값이 들어가면 자동으로 무시됨

집합 연산에 적합
→ 합집합, 교집합, 차집합 같은 연산 구현이 쉬움

즉, 고유한 값들의 모음을 관리할 때 유용
```

## 13-01-04
**Map 컬렉션**  
- Key-Value 쌍으로 데이터를 저장하는 자료구조
- 대표적인 구현 클래스로 HashMap, Hashtable, TreeMap이 있다.
- HashMap과 Hashtable은 hashCode()와 equals()를 이용해서 중복 키를 판별한다.
- 멀티 스레드 환경에서는 HashMap보다 Hashtable이 스레드에 안전하다.

- Map의 개념
```
Key와 Value를 쌍(pair)으로 저장
→ Key는 고유해야 하고 중복 불가, Value는 중복 허용

Key를 이용해 Value를 빠르게 검색
→ 인덱스 대신 Key로 접근

순서 없음 (단, 일부 구현체는 입력 순서를 유지)

즉, 사전(dictionary)처럼 "단어(Key) → 뜻(Value)" 형태로 데이터를 다룰 때 적합
```

## 13-01-05
- 싱글 스레드 환경에서 Board 객체를 순서에 맞게 읽고 싶을 때 가장 적합한 컬랙션
```
List<Board> 변수 = new ArrayList<Board>
```

## 13-01-06
- 싱글 스레드 환경에서 학번(String)을 키로, 점수(Integer)를 값으로 저장하는 가장 적합한 컬랙션
```
Map<String, Integer> 변수 = new HashMap<String, Integer>
```

## 13-01-07
- BoardDao 사용 클래스 [ListExample.java]()  
- 게시물 클래스 [Board.java]()  
- 게시물을 가져오는 클래스 [BoardDao.java]()  

-  실행 흐름
```
ListExample.main() → BoardDao dao = new BoardDao();

dao.getBoardList() 호출 → List<Board> 생성 → Board 3개 넣고 반환

for(Board board : list) 반복문으로 제목-내용 출력
```